import MatrixActionTable from './MatrixActionTable';
import MatrixAction from './MatrixAction';
// Autogenerated using npm run gen MatrixActions
/*
 * Copy to other files
 * import MatrixActions from './MatrixActions';
 * <MatrixActions/>
 */
import styled from 'styled-components';
// import PropTypes from 'prop-types';
// import { Link, Switch, Route } from 'react-router-dom';

function MatrixActions(props) {
  const deck = props.cyberdeckData;
  const values = {
    Attack: deck.attributes.attack,
    Sleaze: deck.attributes.sleaze,
    'Data Processing': deck.attributes.dataProcessing,
    Firewall: deck.attributes.firewall,
    Logic: deck.attributes.logic,
    Intuition: deck.attributes.intuition,
    Willpower: deck.attributes.willpower,
    Reaction: deck.attributes.reaction,
    Computer: deck.skills.computer,
    Cybercombat: deck.skills.cybercombat,
    'Electronic Warfare': deck.skills.electronicWarfare,
    Hacking: deck.skills.hacking,
    Hardware: deck.skills.hardware,
    Software: deck.skills.software,
    runningSilent: deck.runningSilent,
    grid: deck.grid,
    mode: deck.mode,
    matrixActionBonus: 0,
  };

  const actionsSorted = props.matrixActions.actions.sort((a, b) => {
    const itemOneName = a.name.toLowerCase();
    const itemOneLimit = a.limit.offense.toLowerCase();
    const itemTwoName = b.name.toLowerCase();
    const itemTwoLimit = b.limit.offense.toLowerCase();
    if (itemOneLimit > itemTwoLimit) return 1;
    if (itemOneLimit < itemTwoLimit) return -1;
    if (itemOneName > itemTwoName) return 1;
    if (itemOneName < itemTwoName) return -1;

    // return b.name.toLowerCase() < a.name.toLowerCase() ? 1 : -1;
  });

  const actionValues = action => {
    const placeholder = true;
    const offenseLimit = isNaN(values[action.limit.offense])
      ? 'None'
      : values[action.limit.offense];

    let offenseCalc = 0 + values.matrixActionBonus;
    let defenseCalc = 0 + values.matrixActionBonus;
    offenseCalc += values.mode === 'hot' ? 2 : 0;
    defenseCalc += values.mode === 'hot' ? 2 : 0;
    offenseCalc += values.runningSilent === 'hot' ? -2 : 0;
    defenseCalc += values.runningSilent === 'hot' ? -2 : 0;

    const offenceNames = action.test.offense.map((item, key, arr) =>
      arr.length - 1 != key ? (
        <span key={key}>{item} + </span>
      ) : (
        <span key={key}>{item}</span>
      )
    );

    const defenceNames = action.test.defense.map((item, key, arr) =>
      arr.length - 1 != key ? (
        <span key={key}>{item} + </span>
      ) : (
        <span key={key}>{item}</span>
      )
    );

    action.test.offense.map(item => {
      offenseCalc += isNaN(values[item]) ? 0 : values[item];
    });

    action.test.defense.map(item => {
      defenseCalc += isNaN(values[item]) ? 0 : values[item];
    });

    defenseCalc = defenseCalc === 0 ? 'N/A' : defenseCalc;

    const desc = placeholder
      ? 'Placeholder Description Text'
      : action.description;

    return {
      actionType: action.actionType,
      marks: action.marks,
      defenseCalc,
      defenceNames,
      desc,
      limit: action.limit.offense,
      name: action.name,
      offenseLimit,
      offenseCalc,
      offenceNames,
      source: action.source,
    };
  };

  const matrixAction = actionsSorted.map((item, key) => (
    <div className="col-2" key={key}>
      <MatrixAction matrixAction={item} values={actionValues(item)} />
    </div>
  ));

  return (
    <Main className="container-fluid">
      <h2 className="jumbotron d-flex justify-content-center">
        Matrix Actions
      </h2>

      <MatrixActionTable values={values} actions={actionsSorted} />
      <div className="d-flex flex-wrap">{matrixAction}</div>
    </Main>
  );
}

MatrixActions.propTypes = {
  cyberdeckData: PropTypes.object,
  matrixActions: PropTypes.object,
};

export default MatrixActions;

const Main = styled.div`
  font-family: sans-serif;
  padding-top: 20px;
  color: black;
`;
