import MatrixActionTable from './MatrixActionTable';
import MatrixAction from './MatrixAction';
// Autogenerated using npm run gen MatrixActions
/*
 * Copy to other files
 * import MatrixActions from './MatrixActions';
 * <MatrixActions/>
 */
import styled from 'styled-components';
// import PropTypes from 'prop-types';
// import { Link, Switch, Route } from 'react-router-dom';

function MatrixActions(props) {
  const deck = props.cyberdeckData;
  const values = {
    Attack: deck.attributes.attack,
    Sleaze: deck.attributes.sleaze,
    'Data Processing': deck.attributes.dataProcessing,
    Firewall: deck.attributes.firewall,
    Logic: deck.attributes.logic,
    Intuition: deck.attributes.intuition,
    Willpower: deck.attributes.willpower,
    Reaction: deck.attributes.reaction,
    Computer: deck.skills.computer,
    Cybercombat: deck.skills.cybercombat,
    'Electronic Warfare': deck.skills.electronicWarfare,
    Hacking: deck.skills.hacking,
    Hardware: deck.skills.hardware,
    Software: deck.skills.software,
    runningSilent: deck.runningSilent,
    grid: deck.grid,
    mode: deck.mode,
    matrixActionBonus: 0,
  };

  const actionsSorted = props.matrixActions.actions.sort((a, b) => {
    const itemOneName = a.name.toLowerCase();
    const itemOneLimit = a.limit.toLowerCase();
    const itemTwoName = b.name.toLowerCase();
    const itemTwoLimit = b.limit.toLowerCase();
    if (itemOneLimit > itemTwoLimit) return 1;
    if (itemOneLimit < itemTwoLimit) return -1;
    if (itemOneName > itemTwoName) return 1;
    if (itemOneName < itemTwoName) return -1;

    // return b.name.toLowerCase() < a.name.toLowerCase() ? 1 : -1;
  });

  const actionValues = (action) => {
    const placeholder = false;
    const offenseLimit = isNaN(values[action.limit])
      ? 'None'
      : values[action.limit];

    let offenseCalc = 0 + values.matrixActionBonus;
    let defenseCalc = 0 + values.matrixActionBonus;
    offenseCalc += values.mode === 'hot' ? 2 : 0;
    defenseCalc += values.mode === 'hot' ? 2 : 0;
    offenseCalc += values.runningSilent ? -2 : 0;
    defenseCalc += values.runningSilent ? -2 : 0;

    const offenseNames = action.test.offense.join(' + ');

    const defenseNames = action.test.defense.join(' + ');

    action.test.offense.map((item) => {
      offenseCalc += isNaN(values[item]) ? 0 : values[item];
    });

    action.test.defense.map((item) => {
      defenseCalc += isNaN(values[item]) ? 0 : values[item];
    });

    defenseCalc = !defenseCalc ? 'N/A' : defenseCalc;
    offenseCalc = !offenseCalc ? 'N/A' : offenseCalc;

    const desc = placeholder
      ? 'Placeholder Description Text'
      : action.description;

    return {
      ...action,
      defenseCalc,
      defenseNames,
      desc,
      offenseLimit,
      offenseCalc,
      offenseNames,
    };
  };

  const matrixAction = actionsSorted.map((action, key) => (
    <div className="col-2" key={key}>
      <MatrixAction values={actionValues(action)} />
    </div>
  ));

  const matrixTableActions = actionsSorted.map((action) => {
    return actionValues(action);
  });

  return (
    <Main className="container-fluid bg-dark">
      <Jumbo className="jumbotron d-flex justify-content-center">
        Matrix Actions
      </Jumbo>

      <MatrixActionTable actions={matrixTableActions} />
      <ActionCards className="d-flex flex-wrap">{matrixAction}</ActionCards>
    </Main>
  );
}

MatrixActions.propTypes = {
  cyberdeckData: PropTypes.object,
  matrixActions: PropTypes.object,
};

export default MatrixActions;

const Main = styled.div`
  font-family: Open Sans;
  padding-top: 20px;
  font-weight: 600;
`;

const ActionCards = styled.div`
  padding-top: 1.2em;
`;

const Jumbo = styled.h2`
  font-weight: 700;
`;
