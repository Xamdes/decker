// Autogenerated using npm run gen MatrixActions
import MatrixActionTable from './MatrixActionTable';
import styled from 'styled-components';
import PropTypes from 'prop-types';
import { connect } from 'react-redux';

function MatrixActions(props) {
  const values = {
    ...props.attributes,
    ...props.deckingDevice,
    ...props.deckingDevice.attributes,
    ...props.skills,
    matrixActionBonus: 0,
  };

  const actionsSorted = props.matrixActions.actions.sort((a, b) => {
    const itemOneName = a.name.toLowerCase();
    const itemOneLimit = a.limit.toLowerCase();
    const itemTwoName = b.name.toLowerCase();
    const itemTwoLimit = b.limit.toLowerCase();
    if (itemOneLimit > itemTwoLimit) return 1;
    if (itemOneLimit < itemTwoLimit) return -1;
    if (itemOneName > itemTwoName) return 1;
    if (itemOneName < itemTwoName) return -1;
  });

  const actionValues = (action) => {
    const placeholder = false;
    let offenseLimit = 'None';
    switch (action.limit) {
      case 'Attack':
        offenseLimit = props.deckingDevice.attributes['attack'].ranks;
        break;
      case 'Data Processing':
        offenseLimit = props.deckingDevice.attributes['data processing'].ranks;
        break;
      case 'Firewall':
        offenseLimit = props.deckingDevice.attributes['firewall'].ranks;
        break;
      case 'Sleaze':
        offenseLimit = props.deckingDevice.attributes['sleaze'].ranks;
        break;
      default:
        offenseLimit = 'None';
    }

    let offenseCalc = 0 + values.matrixActionBonus;
    let defenseCalc = 0 + values.matrixActionBonus;
    offenseCalc += values.mode === 'hot' ? 2 : 0;
    defenseCalc += values.mode === 'hot' ? 2 : 0;
    offenseCalc += values.runningSilent ? -2 : 0;
    defenseCalc += values.runningSilent ? -2 : 0;

    const offenseNames = action.test.offense.join(' + ');

    const defenseNames = action.test.defense.join(' + ');

    action.test.offense.map((text) => {
      const textLower = text.toLowerCase();
      const item = values[textLower];
      if (typeof item === 'object' && item !== null) {
        offenseCalc += item.ranks;
      }
    });

    action.test.defense.map((text) => {
      const textLower = text.toLowerCase();
      const item = values[textLower];
      if (typeof item === 'object' && item !== null) {
        defenseCalc += item.ranks;
      }
    });

    defenseCalc = !defenseCalc ? 'N/A' : defenseCalc;
    offenseCalc = !offenseCalc ? 'N/A' : offenseCalc;

    const desc = placeholder
      ? 'Placeholder Description Text'
      : action.description;

    return {
      ...action,
      defenseCalc,
      defenseNames,
      desc,
      offenseCalcLimit: offenseCalc.toString() + ' [' + offenseLimit + ']',
      offenseNames,
    };
  };

  const matrixTableActions = actionsSorted.map((action) => {
    return actionValues(action);
  });

  return (
    <Main className="bg-dark">
      <Jumbo className="jumbotron d-flex justify-content-center">
        Matrix Actions
      </Jumbo>

      <MatrixActionTable actions={matrixTableActions} />
    </Main>
  );
}

MatrixActions.propTypes = {
  matrixActions: PropTypes.object,
  deckingDevice: PropTypes.object,
  attributes: PropTypes.object,
  skills: PropTypes.object,
};

function mapStateToProps(state) {
  return {
    deckingDevice: state.deckingDevice,
    attributes: state.attributes,
    skills: state.skills,
    matrixActions: state.matrixActions,
  };
}

const mapDispatchToProps = {};

export default connect(
  mapStateToProps,
  mapDispatchToProps
)(MatrixActions);

const Main = styled.div`
  font-family: Open Sans;
  padding-top: 20px;
  font-weight: 600;
`;

const Jumbo = styled.h2`
  font-weight: 700;
`;
